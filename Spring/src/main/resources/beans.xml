<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:c="http://www.springframework.org/schema/c"
	xsi:schemaLocation=
		"http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"
        default-lazy-init="true">
    <!-- abstract bean which is lazy initial. -->
	<!-- bean start -->
	<bean id="setterUser" class="com.study.spring.base.domain.User">
		<property name="name" value="TOM"/>
		<property name="age" value="23"/>
		<property name="married" value="false" />
		<property name="sex" value="M" />
	</bean>
	<!-- dependency injection start -->
	<!-- *****setter based dependency injection start**** -->
	<bean id="setterDIBean" class="com.study.spring.bean.ioc.DependencyInjection">
		<property name="setterBasedUser" ref="setterUser" />
	</bean>
	<!-- *****setter based dependency injection end***** -->
	<!-- *****constructor based dependency start***** -->
	<bean id="constDIBean1" class="com.study.spring.bean.ioc.DependencyInjection">
		<!-- constructor-arg 顺序与构造方法参数顺序无需一致，根据参数类型注入， 适用于参数类型不同-->
		<constructor-arg type="int" value="20"/>
		<constructor-arg type="java.lang.String" value="TOM"/>
	</bean>
	<bean id="constDIBean2" class="com.study.spring.bean.ioc.DependencyInjection">
		<!-- 如果参数类型相同，就可能注入乱套-->
		<constructor-arg type="java.lang.String" value="KITTY"/>
		<constructor-arg type="java.lang.String" value="NanJing"/>
	</bean>
	<bean id="constDIBean3" class="com.study.spring.bean.ioc.DependencyInjection">
		<!-- 针对参数类型相同的情况，可以通过index指定对应关系-->
		<constructor-arg index="1" value="KITTY"/>
		<constructor-arg index="0" value="NanJing"/>
	</bean>
	<bean id="constDIBean4" class="com.study.spring.bean.ioc.DependencyInjection">
		<!-- 其他较复杂的情况需要同时使用类型和index-->
		
		<constructor-arg index="0" value="KITTY"/>
		<constructor-arg index="2" value="NanJing"/>
		<constructor-arg index="1" value="M"/>
		
		<!-- 
			<constructor-arg index="0" value="TOM"/>
			<constructor-arg index="2" value="BeiJing"/>
			<constructor-arg index="1" value="F"/>
		 -->
	</bean>
	<bean id="constDIBean5" class="com.study.spring.bean.ioc.DependencyInjection">
		<!-- 使用构造方法参数名称匹配 -->
		<constructor-arg name="nam" value="KITTY"/>
		<constructor-arg name="locatio" value="NanJing"/>
		<constructor-arg name="se" value="M"/>
	</bean>
	<!-- *****constructor based dependency end***** -->
	<!-- *****factory dependency injection start***** -->
	<!-- 非静态工厂 -->
	<!-- 注册工厂bean -->
	<bean id="userFactory" class="com.study.spring.bean.ioc.UserFactory" />
	<!-- 目标bean class 可以不写 -->
	<bean id="factoryDIBean" 
		factory-bean="userFactory"
		factory-method="createUser"/>
	<!-- 静态工厂 -->
	<!-- 目标bean class不用写 -->
	<bean id="staticFactoryDIBean" 
		class="com.study.spring.bean.ioc.UserFactory" 
		factory-method="staticCreateUser" scope="prototype"/>
	<!-- *****factory dependency injection end***** -->
	<!-- dependency injection end -->
	<!-- 
		向singleton bean中注入prototype bean，并且每次调用都能获取不同的prototype bean的两种实现方式
		1. singleton bean实现BeanFactoryAware接口，与Spring框架耦合度高，不建议使用
		2. lookup方法注入，即通过动态代理的方式注入prototype bean
	 -->
	 <bean id="prototypeBean" class="com.study.spring.base.domain.User" scope="prototype">
		<property name="name" value="TOM"/>
		<property name="age" value="23"/>
		<property name="married" value="false" />
		<property name="sex" value="M" />
	 </bean>
	 <bean id="singletonBean1" class="com.study.spring.bean.ioc.InjectPB2SBBaseOnSpring"/>
	 <bean id="singletonBean2" class="com.study.spring.bean.ioc.InjectPB2SBBaseOnDynamicProxy">
	 	<lookup-method bean="prototypeBean" name="getUser"/>
	 </bean>
	 <!-- configuration detail start -->
	 <!-- 
	 	1. idref 引用配置文件中配置的bean的id(字符串)，为其他bean的属性赋值。相当于value，只不过会多一步验证，如果引用的id不存在将会抛错
	 -->
	 <bean id="idrefBean" class="com.study.spring.base.domain.User">
	 	<property name="name">
	 		<idref bean="setterUser"/>
	 	</property>
	 	<!-- 相当于 <property name="name" value="setterUser" /> -->
	 </bean>
	 <!-- 
	 	2. ref 引用其他bean对应的实例，ref有三个属性可选：
	 		bean: 可以引用所有配置的bean
	 		local: 仅能引用当前配置文件中的bean
	 		parent: 引用parent中的bean
	 -->
	 
	 <!-- 
	 	3. inner bean 在一个bean的<property/>或<constructor-arg/>元素内定义的bean, 不必id，name属性
	  -->
	 <bean id="innerBean" class="com.study.spring.bean.ioc.DependencyInjection">
	 	<property name="setterBasedUser">
	 		<bean class="com.study.spring.base.domain.User">
	 			<property name="name" value="KITTY"/>
				<property name="age" value="12"/>
				<property name="married" value="false" />
				<property name="sex" value="F" />
	 		</bean>
	 	</property>
	 </bean>
	 <!-- 
	 	4. 集合 spring支持List，Set，Map，Properties等集合属性的注入
		 	List:
		 		<bean id="..." class="...">
				 	<property name="...">
				 		<list>
				 			<value>...</value>
				 			<ref/> // 可以引用其他bean
				 		</list>
				 	</property>
		 		</bean>
		 	Set: 同List
		 	Map:
		 		<bean id="..." class="...">
				 	<property name="...">
				 		<map>
				 			<entry key="..." value="..." />
				 			<entry key="..." value-ref="..." />
				 		</map>
				 	</property>
		 		</bean>
		 	Properties:
		 		<bean id="..." class="...">
				 	<property name="...">
				 		<props>
				 			<prop key="...">...</prop>
				 		</props>
				 	</property>
		 		</bean>
		 		或者:
		 		<bean id="..." class="...">
				 	<property name="...">
				 		<value>
				 			xx=xx
				 			xxx=xxx
				 		</value>
				 	</property>
		 		</bean>
	  -->
	 
	 <!-- 
	 	5. NULL和空值
	 		null用<null /> 元素表示
	 		""用value="" 表示
	  -->
	  
	  <!-- 
	  	6. 命名空间p，c， 简化配置
	  		p:在beans节点中添加命名空间pxmlns:p="http://www.springframework.org/schema/p"
	  		使用命名空间p后，在定义bean的时候，可以使用"p:属性=xxx"或"p:属性-ref"的行级属性形式代替<propertity />
	  		如上面的SetterDIBean可以使用以下形式定义:
	  		<bean id="setterDIBean" class="com.study.spring.bean.ioc.DependencyInjection" 
	  			p:setterBasedUser-ref="setterUser"
	  			p:name="xxx"/>
	  			
	  		c:在beans节点中添加命名空间pxmlns:c="http://www.springframework.org/schema/c"
	  		在定义构造方法注入的bean中，使用"c:属性=xxx"或"p:属性-ref"的行级属性形式代替<constructor-arg />
	  		如上面的constDIBean1可以使用以下形式定义:
	  		<bean id="constDIBean1" class="com.study.spring.bean.ioc.DependencyInjection"
	  			c:name="xxx"
	  			c:age="xxx" />
	   -->
	   
	   <!--
	   	 7. depends-on
	   	 	bean A 依赖于bean B，如果不能确定初始化A时B是否已经实例化，使用depends-on属性，确保依赖bean B在A之前实例化
	   	 	多个依赖之间用,;或空格间隔：fooBean;barBean
	   	 	例如:
	   	 	<bean id="..." class="..." p:foo-ref="fooBean" depends-on="fooBean" />
	   -->
	   <bean id="dependsOnBean" class="com.study.spring.bean.ioc.DependencyInjection" depends-on="fooUser" />
	   <bean id="fooUser" class="com.study.spring.base.domain.User">
			<property name="name" value="foo"/>
			<property name="age" value="23"/>
			<property name="married" value="false" />
			<property name="sex" value="M" />
		</bean>
	   <!-- 
	   	 8. Lazy-initialized
	   	 	Spring在初始化容器时默认实例化singleton bean，如果希望某个bean使用时再实例化，可以指定lazy-init="true"
	   	 	<bean id="..." class="..."  lazy-init="true"/>
	   	 	全局的实例化机制也是支持的，在beans节点上添加default-lazy-init="true":
	   	 	<beans default-lazy-init="true" />
	   	 	Spring会在启动时实例化非延迟实例化 singleton bean的依赖bean，而不论该依赖bean是否延迟实例化
	    -->
	    
	    <!-- 
	      9. 自动装配
	      	不需要指定依赖，依靠spring容器自动装配
	      	三种装配方式（默认不使用自动装配）：
	      		- by name 自动注入与该bean属性名相同的bean
	      		- by type 自动注入与该bean属性类型相同的bean
	      		- constructor 自动注入与该bean构造函数参数类型相同的bean
	      	<bean autowire="true"></bean>
	     -->
	     
	 <!-- configuration detail end -->
	<!-- bean end -->
</beans>