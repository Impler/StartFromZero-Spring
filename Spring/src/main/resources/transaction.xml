<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.1.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-3.1.xsd">
        
        <import resource="dao.xml"/>
	<!-- 
		数据库事务：多条sql，全部执行成功则成功，有一条失败则全部失败
		事务的4个特性：
		原子性：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交，事务中任何一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库恢复到初始状态
		一致性：事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏。如A转给B100元，不管成功与否，A、B总额不变
		隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，他们的操作不会对对方产生干扰
		持久性：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使数据库崩溃，重启后必须要能保证可以通过某种机制恢复数据
		
		数据并发可能引起的问题：
		脏读：A事务读取B事务尚未提交的更改数据，并在此基础上操作。如果恰巧B事务回滚，那么A事务读到的数据是不被承认的
		不可重复读：A事务读取了B事务已经提交的更改数据。如在A事务两次查询数据间隔内，B修改提交了数据，导致A两次查询数据不一致
		幻象读：A事务读取到B事务提交的新增数据。不可重复读是指读到了已经提交事务的更改数据，而幻象读是指读到了已经提交事务的新增数据
		第一类丢失更新：A事务撤销时，覆盖B事务已经更新的数据
		第二类丢失更新；A事务提交时，覆盖B事务已经提交的数据
	 -->
	 <!-- 
	 	Spring事务管理的亮点在于声明式事务管理。通过声明方式，在IoC配置中制定事务的边界和事务的属性，Spring自动在制定的事务边界上应用事务属性。
	 	Spring的声明式事务管理是通过Spring AOP实现的，通过事务的声明性信息，Spring负责将事务管理增强逻辑动态植入到业务方法相应连接点中。这些逻辑包括获取线程绑定资源、开始事务、提交/回滚事务、进行异常转换和处理等工作
	  -->
	  
	  <!-- 
	  	在Spring的早期版本，用户必须使用原始的TransactionProxyFactoryBean对需要事务管理的业务类进行代理，以便实施事务功能的增强
	   -->
	  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"
	  	p:dataSource-ref="dataSource"/>
	  	
	  <bean id="logDao" class="com.study.spring.transaction.LogDaoImpl"></bean>
	  <bean id="userDao" class="com.study.spring.transaction.UserDaoImpl"></bean>
	  
	  <!-- 需要实施事务增强的目标业务bean，通常以xxxTarget命名 -->
	  <bean id="userServiceTarget" class="com.study.spring.transaction.UserService"
	  	p:logDao-ref="logDao"
	  	p:userDao-ref="userDao" />
	  <!-- 使用原始的TransactionProxyFactoryBean实施事务增强 start -->
	  <!-- 使用事务代理工厂类为目标业务Bean提供事务增强 -->
	  <bean id="userService" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"
	  	p:transactionManager-ref="txManager"
	  	p:target-ref="userServiceTarget">
	  		<!-- 事务属性配置 -->
	  		<property name="transactionAttributes">
	  			<!-- 
	  				配置事务属性信息，格式为：
	  				传播行为,隔离级别(可选),是否为只读事务(可选),-发生这些异常时回滚事务(可选),-发生这些异常时照样提交事务(可选)
	  				传播行为：控制当前的事务如何传播到被嵌套调用的目标接口方法中，Spring定义了7种类型的事务传播
	  					- PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务；如果已经存在一个事务，加入到这个事务中
	  					- PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行
	  					- PROPAGATION_MANDATORY 使用当前事务，如果当前没有事务，就抛出异常
	  					- PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起
	  					- PROPAGATION_NOT_SUPPORTED 以非事务方式执行，如果当前存在事务，就把当前事务挂起
	  					- PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，就抛出异常
	  					- PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似操作
	  				隔离级别：
	  					- ISOLATION_DEFAULT
	  					- ISOLATION_READ_UNCOMMITTED
	  					- ISOLATION_READ_COMMITTED
	  					- ISOLATION_REPEATABLE_READ
	  					- ISOLATION_SERIALIZABLE
	  				只读事务：使用readOnly配置
	  				异常：-或+异常类名，或异常类名匹配片段
	  					Spring采用简单字符串包含的比较方式，判断实际抛出的异常是否与配置匹配。抛出的异常或该异常的祖先类的类名匹配规则中自定的异常类名（或异常名片断），规则就生效
	  					Spring默认的事务回滚规则为：运行期异常回滚，检查型异常不会滚
	  					
	  			-->
	  			<props>
	  				<!-- 只读事务，匹配UserService中以reg开头的方法 -->
	  				<prop key="reg*">PROPAGATION_REQUIRED,readOnly</prop>
	  				<!-- 可写事务，匹配UserService所有方法 -->
	  				<prop key="*">PROPAGATION_REQUIRED</prop>
	  			</props>
	  		</property>
	  </bean>
	  <!-- 使用原始的TransactionProxyFactoryBean实施事务增强 end -->
	  
	  <!-- 使用AOP实施事务增强 start -->
	  <aop:config>
	  	<aop:pointcut expression="execution(* com.study.spring.transaction.*Service.*(..))" id="serviceMethod"/>
	  	<aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethod"/>
	  </aop:config>
	  
	  <tx:advice id="txAdvice" transaction-manager="txManager">
	  	<tx:attributes>
	  		<tx:method name="reg*" read-only="false" rollback-for="Exception"/>
	  	</tx:attributes>
	  </tx:advice>
	  <!-- 使用AOP实施事务增强 end -->
</beans>